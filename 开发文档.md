# Lark 多维表格 Bug 和需求管理系统开发文档

## 项目概述

本项目旨在从 Lark 的多维表格中获取 Bug 一览和需求一览，并构建一个基于 Bug 一览的任务管理系统。

## 技术架构

### 核心技术栈
- **Lark OpenAPI MCP**: 用于与 Lark 多维表格进行交互
- **Node.js**: 后端运行环境
- **数据库**: 用于存储任务系统数据（建议使用 PostgreSQL 或 MongoDB）
- **前端框架**: React/Vue（用于构建任务管理界面）

### 系统架构图
```
┌─────────────────┐     ┌──────────────────┐     ┌─────────────────┐
│  Lark 多维表格  │────▶│  Lark OpenAPI    │────▶│   任务系统      │
│  - Bug 一览     │     │      MCP         │     │  - 任务管理     │
│  - 需求一览     │     │                  │     │  - 状态跟踪     │
└─────────────────┘     └──────────────────┘     └─────────────────┘
```

## 环境配置

### 1. 前置准备

1. 在飞书开放平台创建应用
   - 访问 [飞书开放平台](https://open.feishu.cn/)
   - 创建新应用并获取 App ID 和 App Secret
   - 配置所需权限：
     - `bitable:table:read` - 读取多维表格数据
     - `bitable:table:write` - 写入多维表格数据
     - `bitable:app:read` - 读取多维表格应用信息

2. 安装 Node.js（推荐 v18+）

### 2. 安装 Lark OpenAPI MCP

```bash
# 全局安装
npm install -g @larksuiteoapi/lark-mcp

# 或使用 npx 直接运行
npx -y @larksuiteoapi/lark-mcp
```

### 3. 配置环境变量

创建 `.env` 文件：

```env
LARK_APP_ID=cli_xxxx
LARK_APP_SECRET=yyyyy
LARK_BUG_TABLE_ID=xxxxx
LARK_REQUIREMENT_TABLE_ID=xxxxx
DATABASE_URL=postgresql://user:password@localhost:5432/task_system
```

## 核心功能实现

### 1. 连接 Lark 多维表格

```javascript
// larkClient.js
const { LarkMCP } = require('@larksuiteoapi/lark-mcp');

class LarkTableClient {
  constructor(appId, appSecret) {
    this.appId = appId;
    this.appSecret = appSecret;
    this.client = null;
  }

  async initialize() {
    // 初始化 MCP 客户端
    this.client = new LarkMCP({
      appId: this.appId,
      appSecret: this.appSecret,
      oauth: true // 启用自动令牌管理
    });
  }

  // 获取多维表格数据
  async getTableRecords(tableId, viewId = null) {
    const params = {
      app_token: tableId,
      table_id: tableId
    };
    
    if (viewId) {
      params.view_id = viewId;
    }

    return await this.client.bitable.record.list(params);
  }

  // 更新记录
  async updateRecord(tableId, recordId, fields) {
    return await this.client.bitable.record.update({
      app_token: tableId,
      table_id: tableId,
      record_id: recordId,
      fields: fields
    });
  }
}

module.exports = LarkTableClient;
```

### 2. Bug 数据模型

```javascript
// models/Bug.js
class Bug {
  constructor(data) {
    this.id = data.record_id;
    this.title = data.fields['标题'];
    this.status = data.fields['状态'];
    this.priority = data.fields['优先级'];
    this.assignee = data.fields['负责人'];
    this.createdAt = data.fields['创建时间'];
    this.description = data.fields['描述'];
    this.module = data.fields['模块'];
    this.severity = data.fields['严重程度'];
  }

  // 转换为任务格式
  toTask() {
    return {
      id: this.id,
      title: `[BUG] ${this.title}`,
      type: 'bug',
      status: this.mapStatus(this.status),
      priority: this.priority,
      assignee: this.assignee,
      dueDate: this.calculateDueDate(),
      tags: [this.module, this.severity],
      sourceId: this.id,
      sourceType: 'lark_bug'
    };
  }

  mapStatus(larkStatus) {
    const statusMap = {
      '待处理': 'pending',
      '处理中': 'in_progress',
      '已修复': 'resolved',
      '已关闭': 'closed',
      '重新打开': 'reopened'
    };
    return statusMap[larkStatus] || 'pending';
  }

  calculateDueDate() {
    // 根据优先级计算截止日期
    const priorityDays = {
      '紧急': 1,
      '高': 3,
      '中': 7,
      '低': 14
    };
    const days = priorityDays[this.priority] || 7;
    const dueDate = new Date();
    dueDate.setDate(dueDate.getDate() + days);
    return dueDate;
  }
}

module.exports = Bug;
```

### 3. 任务系统设计

```javascript
// taskSystem.js
class TaskSystem {
  constructor(larkClient, database) {
    this.larkClient = larkClient;
    this.db = database;
  }

  // 同步 Bug 到任务系统
  async syncBugsToTasks() {
    try {
      // 1. 从 Lark 获取 Bug 列表
      const bugRecords = await this.larkClient.getTableRecords(
        process.env.LARK_BUG_TABLE_ID
      );

      // 2. 转换为任务
      const tasks = bugRecords.items.map(record => {
        const bug = new Bug(record);
        return bug.toTask();
      });

      // 3. 批量更新数据库
      await this.db.tasks.upsertMany(tasks);

      return {
        synced: tasks.length,
        timestamp: new Date()
      };
    } catch (error) {
      console.error('同步失败:', error);
      throw error;
    }
  }

  // 创建任务
  async createTask(taskData) {
    const task = await this.db.tasks.create(taskData);
    
    // 如果任务关联 Bug，更新 Lark 表格
    if (task.sourceType === 'lark_bug') {
      await this.updateBugStatus(task.sourceId, task.status);
    }
    
    return task;
  }

  // 更新任务状态
  async updateTaskStatus(taskId, newStatus) {
    const task = await this.db.tasks.findById(taskId);
    
    if (!task) {
      throw new Error('任务不存在');
    }

    // 更新任务状态
    task.status = newStatus;
    await task.save();

    // 同步更新 Lark
    if (task.sourceType === 'lark_bug') {
      await this.updateBugStatus(task.sourceId, newStatus);
    }

    return task;
  }

  // 更新 Lark Bug 状态
  async updateBugStatus(bugId, status) {
    const statusMap = {
      'pending': '待处理',
      'in_progress': '处理中',
      'resolved': '已修复',
      'closed': '已关闭',
      'reopened': '重新打开'
    };

    await this.larkClient.updateRecord(
      process.env.LARK_BUG_TABLE_ID,
      bugId,
      {
        '状态': statusMap[status] || '待处理'
      }
    );
  }

  // 获取任务统计
  async getTaskStatistics() {
    const stats = await this.db.tasks.aggregate([
      {
        $group: {
          _id: '$status',
          count: { $sum: 1 }
        }
      }
    ]);

    const priorityStats = await this.db.tasks.aggregate([
      {
        $group: {
          _id: '$priority',
          count: { $sum: 1 }
        }
      }
    ]);

    return {
      byStatus: stats,
      byPriority: priorityStats,
      total: await this.db.tasks.count()
    };
  }
}

module.exports = TaskSystem;
```

### 4. 定时同步服务

```javascript
// syncService.js
const cron = require('node-cron');

class SyncService {
  constructor(taskSystem) {
    this.taskSystem = taskSystem;
  }

  start() {
    // 每小时同步一次
    cron.schedule('0 * * * *', async () => {
      console.log('开始同步 Lark 数据...');
      try {
        const result = await this.taskSystem.syncBugsToTasks();
        console.log(`同步完成，已同步 ${result.synced} 条记录`);
      } catch (error) {
        console.error('同步失败:', error);
      }
    });

    // 立即执行一次同步
    this.taskSystem.syncBugsToTasks();
  }
}

module.exports = SyncService;
```

## API 接口设计

### 1. 任务相关接口

```javascript
// routes/tasks.js
const express = require('express');
const router = express.Router();

// 获取任务列表
router.get('/api/tasks', async (req, res) => {
  const { status, priority, assignee, page = 1, limit = 20 } = req.query;
  
  const filter = {};
  if (status) filter.status = status;
  if (priority) filter.priority = priority;
  if (assignee) filter.assignee = assignee;

  const tasks = await taskSystem.getTasks(filter, { page, limit });
  res.json(tasks);
});

// 创建任务
router.post('/api/tasks', async (req, res) => {
  const task = await taskSystem.createTask(req.body);
  res.json(task);
});

// 更新任务状态
router.put('/api/tasks/:id/status', async (req, res) => {
  const { status } = req.body;
  const task = await taskSystem.updateTaskStatus(req.params.id, status);
  res.json(task);
});

// 获取任务统计
router.get('/api/tasks/statistics', async (req, res) => {
  const stats = await taskSystem.getTaskStatistics();
  res.json(stats);
});

// 手动触发同步
router.post('/api/sync', async (req, res) => {
  const result = await taskSystem.syncBugsToTasks();
  res.json(result);
});

module.exports = router;
```

## 数据库设计

### 任务表（tasks）

```sql
CREATE TABLE tasks (
  id VARCHAR(255) PRIMARY KEY,
  title VARCHAR(500) NOT NULL,
  type VARCHAR(50) NOT NULL, -- bug, requirement, task
  status VARCHAR(50) NOT NULL,
  priority VARCHAR(50),
  assignee VARCHAR(255),
  description TEXT,
  tags JSON,
  source_id VARCHAR(255),
  source_type VARCHAR(50), -- lark_bug, lark_requirement, manual
  due_date TIMESTAMP,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  INDEX idx_status (status),
  INDEX idx_assignee (assignee),
  INDEX idx_source (source_id, source_type)
);
```

## 运行与部署

### 1. 本地开发

```bash
# 安装依赖
npm install

# 运行数据库迁移
npm run migrate

# 启动开发服务器
npm run dev
```

### 2. 生产部署

```bash
# 构建项目
npm run build

# 使用 PM2 管理进程
pm2 start ecosystem.config.js

# 或使用 Docker
docker build -t lark-task-system .
docker run -d -p 3000:3000 --env-file .env lark-task-system
```

### 3. 监控与日志

建议配置以下监控：
- API 响应时间监控
- 同步任务成功率监控
- 错误日志收集
- 任务处理效率统计

## 使用示例

### 1. 初始化系统

```javascript
const LarkTableClient = require('./larkClient');
const TaskSystem = require('./taskSystem');
const SyncService = require('./syncService');

async function initializeSystem() {
  // 初始化 Lark 客户端
  const larkClient = new LarkTableClient(
    process.env.LARK_APP_ID,
    process.env.LARK_APP_SECRET
  );
  await larkClient.initialize();

  // 初始化任务系统
  const taskSystem = new TaskSystem(larkClient, database);

  // 启动同步服务
  const syncService = new SyncService(taskSystem);
  syncService.start();

  return { larkClient, taskSystem };
}
```

### 2. 手动同步数据

```javascript
// 手动触发同步
async function manualSync() {
  const result = await taskSystem.syncBugsToTasks();
  console.log(`同步完成: ${result.synced} 条记录`);
}
```

## 注意事项

1. **权限管理**: 确保 Lark 应用具有足够的权限访问多维表格
2. **频率限制**: 注意 Lark API 的调用频率限制，避免过于频繁的请求
3. **数据一致性**: 建议使用事务确保数据同步的一致性
4. **错误处理**: 完善的错误处理和重试机制
5. **性能优化**: 大量数据时考虑分批处理和异步队列

## 扩展功能

1. **需求管理**: 类似 Bug 管理，可以扩展需求一览的同步和管理
2. **自动分配**: 根据规则自动分配任务给合适的人员
3. **通知系统**: 集成飞书机器人，任务状态变更时自动通知
4. **看板视图**: 提供可视化的任务看板
5. **报表分析**: 生成 Bug 趋势、处理效率等报表

## 故障排查

### 常见问题

1. **连接失败**
   - 检查网络连接
   - 验证 App ID 和 App Secret
   - 确认应用权限配置

2. **同步失败**
   - 检查表格 ID 是否正确
   - 确认字段名称匹配
   - 查看错误日志

3. **性能问题**
   - 优化数据库索引
   - 使用分页查询
   - 考虑使用缓存

## 参考资料

- [Lark OpenAPI MCP 文档](https://github.com/larksuite/lark-openapi-mcp)
- [飞书开放平台文档](https://open.feishu.cn/document)
- [多维表格 API 参考](https://open.feishu.cn/document/server-docs/docs/bitable-v1/overview)